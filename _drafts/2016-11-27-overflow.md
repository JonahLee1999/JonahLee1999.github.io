---
layout: post
title: 缓冲区入门及原理——栈溢出
categories: [cate1, cate2]
description: 缓冲区溢出基础
keywords: 系统安全,缓冲区溢出
---

你根本不懂我的ret，就像我不懂你的shellcode。

参考自己随便找到的一份PPT、《Q版缓冲区溢出教程》以及诸多网络博文。

---

### 相关概念

###### 缓冲区溢出：

是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据，事数据覆盖程序为其他数据分配的内存空间），从而破坏程序运行、并获取程序乃至系统的控制权。

以上摘自(wiki百科)[https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA]

###### 缓冲区：

* 从程序的角度，缓冲区就是应用程序用来保存用户输入数据、程序临时数据的内存空间
* 缓冲区本质：数组
* 存储位置：Stack、Heap、数据段


###### 溢出种类

* 栈溢出
* 堆溢出
* 整型溢出
  * 宽度溢出
  * 运算溢出
  * 符号溢出
* 格式化字符串溢出
* 其他溢出，如
  * .data srction溢出
  * PEB/TEB溢出
  * 文件流溢出





### 原理理解

* 理解程序内存空间
* 理解栈（毕竟我这篇讲的是栈溢出）
* 理解函数调用过程
* 理解缓冲区溢出原理


下面是详细讲解栈溢出相关知识，不想看原理的筒子们请直接跳到栈溢出漏洞，那里我写了基本的栈溢出原理以及漏洞利用。这部分原理我自己写的时候也觉得这部分知识介绍的太详细太啰嗦了，写的好累。


#### 程序内存空间

首先来理解一下一个程序在虚拟内存空间是怎样的。

来源于[https://kb.cnblogs.com/page/66608/](https://kb.cnblogs.com/page/66608/)和[http://ju.outofmemory.cn/entry/162347](http://ju.outofmemory.cn/entry/162347)，关于程序在内存中运行讲的很详细，建议看一下。不过我下面的第一张配图是Windows下的程序内存空间，这两篇都是Linux下的程序内存映射空间。

Windows下的内存映射

 ![1](images/overflow/stack-1.JPG)

Linux下的内存映射

![2](images/overflow/stack-2.JPG)

* 栈区(stack segment)：由编译器自动分配释放，存放函数的参数的值，局部变量的值等。在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M(也有的是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
* 堆区(heap segment) ： 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
* BSS：BSS与数据段存储的都是静态（全局）变量。但BSS存储的静态变量没有初始化，所以BSS段没有映射任何文件，所以BSS段在内存中是匿名存在的。例如定义变量static int cnt，那么cnt的数据就保存在BSS段中。
* 初始化代码数据段：数据段储存了在源代码中经过了初始化的静态变量，不匿名。例如static int cnt=10，那么cnt就会赋以初值10并保存在数据段中。不过**这种内存映射是私有的**，所以全局变量的改变应用到了文件在内存中的二进制映像，但是文件本身不能做出相应变化。
* 文本（代码）段：存放程序的代码、指令的区域。dll是动态链接库。机器码。




#### 理解栈

###### 栈的基本知识。

* 栈是一块连续的内存空间（堆不连续，且堆由程序员自己申请）
  * 先入后出
  * 生长方向与内存的生长方向正好相反,从高地址向低地址生长
* 每一个线程有自己的栈
  * 提供一个暂时存放数据的区域
* 使用POP/PUSH指令来对栈进行操作
* 使用ESP寄存器指向栈顶，EBP指向栈帧底


###### 栈的内容

* 函数的参数
* 函数返回地址
* EBP的值
* 一些通用寄存器(EDI,ESI…)的值
* 当前正在执行的函数的局部变量

###### 三个重要寄存器

* SP(ESP)：即栈顶指针，随着数据入栈出栈而发生变化
* BP(EBP)：l即基地址指针，用于标识栈中一个相对稳定的位置。通过BP,可以方便地引用函数参数以及局部变量
* IP(EIP)：l即指令寄存器，在将某个函数的栈帧压入栈中时，其中就包含当前的IP值，即函数调用返回后下一个执行语句的地址

#### 栈帧结构与函数调用栈

来源于：[http://www.cnblogs.com/clover-toeic/p/3755401.html](http://www.cnblogs.com/clover-toeic/p/3755401.html)和[http://blog.csdn.net/wangyezi19930928/article/details/16921927](http://blog.csdn.net/wangyezi19930928/article/details/16921927)

* 栈帧：函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是栈的逻辑片段，当调用函数时逻辑栈帧被压入栈, 当函数返回时逻辑栈帧被从栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。

如图

![3](images/overflow/stack-3.GIF)

栈是从高往低走，所以这张图从上往下看。

EBP是基址指针，保存调用者函数的地址，ESP是被调函数的指针，总是指向函数栈顶。



