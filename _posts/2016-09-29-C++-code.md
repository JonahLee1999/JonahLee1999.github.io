---
layout: post
title: 小学期还算要脑子的题目
categories: 算法
description: 一份来自我实在不知道写啥的描述，就是把小学期还可以的题目放上来，数塔
keywords: 算法
---

小菜鸟小菜鸟啦~题目太简单也请原谅，只是写一点点我们小学期觉得难度还可以的题目

***

### 数塔问题

经典的数塔问题，也是我接触动态规划第一题。

> 题目描述
 
>给定一个数塔，如下图所示。在此数塔中，从顶部出发，在每一节点可以选择走左下或右下，一直走到底层。请找出一条路径，使路径上的数值和最大。
>
>                    9
>                 12   15
>              10    6    8
>            2    18    9    5
>         19   7     10   4    16
>            
>输入
>
>输入时第一行一个整数n，表示该数塔的行数，其余n行表示该塔每行的数值


>输出
>
>输出包含两行，第一行为最大路径上的数值之和， 第二行n个数字为从上而下最大路径数值
>
>样例输入
>
>如上图，不打了
>
>
>样例输出
>
>59
>
>9 12 10 18 10


#### 思想和主要步骤

这题不能采用贪心的方法，不然路径太多。自上往下分析，自下往上构造。用结点来保存当前值。从下往上选择打的相加，

中心算法：
```C++
 b[i][j]=max(b[i+1][j],b[i+1][j+1])+a[i][j];
```

用三个数组，一个保存输入，一个保存当前结点值，一个保存路径。

```
	int **a=new int *[n];//输入结果存储 
	int **b=new int *[n];//结点存储 
	int *c=new int [n];//路径存储 
```

中心思想实现，动态规划，自下往上进行，选择大的结点值相加

```C++
for(int i=n-2;i>=0;i--)//动态规划，自下往上进行， 选择大的结点 
		for(int j=0;j<=i;j++)
		{
			b[i][j]=max(b[i+1][j],b[i+1][j+1])+a[i][j];
		}
```

路径选择，用结点值减去当前上一层数值得到差值，再将差值与当前数值比较

```C++
c[0]=a[0][0];//路径第一位 
	for(int i=1;i<n;i++)
	{
		int m=b[i-1][j]-a[i-1][j];//上一层结点值减去数值，得到差值 
		if(m==b[i][j])//差值即为这层的节点值 
		{
			c[i]=a[i][j];
		}
		else//只有左右两个结点考虑 
		{
			c[i]=a[i][j+1];
			j++;
		}	
	}

```

#### 全部代码实现

```C++
#include<iostream>
using namespace std;
int max(int x,int y)//输出大者 
{
	return x>y?x:y;
}
int main()
{
	int n;
	cin>>n;
	int **a=new int *[n];//输入结果存储 
	int **b=new int *[n];//结点存储 
	int *c=new int [n];//路径存储 
	for(int i=0;i<n;i++)//二维数组 
	{
		a[i]=new int[n];
		b[i]=new int[n];
	}
	for(int i=0;i<n;i++)
		for(int j=0;j<i+1;j++)
			cin>>a[i][j];
	for(int i=0;i<n;i++)
		b[n-1][i]=a[n-1][i];
	for(int i=n-2;i>=0;i--)//动态规划，自下往上进行， 选择大的结点 
		for(int j=0;j<=i;j++)
		{
			b[i][j]=max(b[i+1][j],b[i+1][j+1])+a[i][j];
		}
	cout<<b[0][0]<<endl;
	int j=0;
	c[0]=a[0][0];//路径第一位 
	for(int i=1;i<n;i++)
	{
		int m=b[i-1][j]-a[i-1][j];//上一层结点值减去数值，得到差值 
		if(m==b[i][j])//差值即为这层的节点值 
		{
			c[i]=a[i][j];
		}
		else//只有左右两个结点考虑 
		{
			c[i]=a[i][j+1];
			j++;
		}	
	}
	cout<<c[0];
	for(int i=1;i<n;i++)
	{
		cout<<' '<<c[i];
	}
	return 0;
}
```
***

